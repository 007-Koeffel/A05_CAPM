---
title: "Portfoliomanagement and Financial Analysis - Assignment 5"
subtitle: "Submit until Monday 2019-10-29, 13:00"
author: "KÃ¶ffel, Fabian"
output: html_notebook
---
  
```{r load_packs}
#remotes::install_github("braverock/PortfolioAnalytics",  build_vignettes = TRUE, force = TRUE)
pacman::p_load(tidyverse,tidyquant,FFdownload,PortfolioAnalytics,nloptr,readxl, broom, tibbletime, timetk)
```

**Please** remember to put your assignment solutions in `rmd` format using **many** chunks and putting readable text in between, similar to my examples given in Research Methods and Assignment 1! Also, each student has to select his own set of 10 stocks having data available as of `2000-01-01`. Select by Sharpe-ratio, dominance or any other method (e.g. matching your first name).

For all exercises: Please use the Assignment-Forum to post your questions, I will try my best to help you along!
  
## Exercise 1: Constraints
  
Have a look at `vignette("portfolio_vignette")`. Use your dataset to compute 

a) Minimum-Variance 
b) Maximum Quadratic Utility Portfolios

adding (individually/together) all the different constraints and highlighting the different portfolios (portfolios performances) including rebalancing over an appropriate time-frame. The goal is, that after doing this exercise you are familiar with the constraints and their consequences.

```{r}
#download data

stockselection <- c("AAPL", "MSFT", "AMZN", "JPM", "AMGN", "CSCO", "GILD", "MCD", "QCOM", "WMT")

#Get the prices of the stocks to transmute it to returns
stock.prices <- stockselection %>%
  tq_get(get  = "stock.prices", from = "2000-01-01",to = "2018-08-31") %>%
  group_by(symbol)

#Create monthly returns
stock.returns.monthly <- stock.prices %>%  
  tq_transmute(select = adjusted,
               mutate_fun = periodReturn,
               period="monthly",
               type="arithmetic",
               col_rename = "Stock.returns"
               )
```

```{r}
#put it into a tibble

R <- pivot_wider(stock.returns.monthly,
                                                names_from = symbol,
                                                values_from = c(Stock.returns))%>% 
  tk_xts(date_var = date, silent = TRUE)

colnames(R) <- c("AAPL", "MSFT", "AMZN", "JPM", "AMGN", "CSCO", "GILD", "MCD", "QCOM", "WMT")
funds <- colnames(R)


```

a) Minimum Variance Portfolio

###first example is with the full investment constraint

```{r}
# Create portfolio object
portf_minvar <- portfolio.spec(assets=stockselection)
# Add full investment constraint to the portfolio object
portf_minvar <- add.constraint(portfolio=portf_minvar, type="full_investment")
# Add objective to minimize variance
portf_minvar <- add.objective(portfolio=portf_minvar, type="risk", name="var")
```


```{r}
# Run the optimization
opt_gmv <- optimize.portfolio(R=R, portfolio=portf_minvar,
                              optimize_method="ROI", trace=TRUE)
print(opt_gmv)
```
#in Amazon and QCOM we would go for short

```{r}
portf_minvaref<- create.EfficientFrontier(R=R, portfolio = portf_minvar, type = "mean-StdDev", match.col = "StdDev")
chart.EfficientFrontier(portf_minvaref, match.col = "StdDev", type = "b", rf = NULL, pch.assets = 1)
```


```{r}
#rebalancing
bt_gmv <- optimize.portfolio.rebalancing(R=R,portfolio=portf_minvar,
                                         optimize_method="ROI",
                                         rebalance_on="months",
                                         training_period=156)

#we chose a training period of 156 months --> 13 years to have enough historical data to use for reblancing and moreover our chart is easier to read 
#furthermore, we chose monthly rebalancing, because we have monthly data and it is important to rebalance as soon and as often as possible

bt_gmv

chart.Weights(bt_gmv)
returns_gmv <- Return.portfolio(R = R, weights = extractWeights(bt_gmv))
```

###second we use a long-only constraint

```{r}
# Add long only constraints to a new portfolio to show the difference
#so we do not allow for short selling now

portf_minvar_2 <- portfolio.spec(assets=stockselection)
portf_minvar_2 <- add.constraint(portfolio=portf_minvar_2, type="box",
                               min=0, max=1)
portf_minvar_2 <- add.objective(portfolio=portf_minvar_2, type="risk", name="var")
```

```{r}
#Optimization
# Run the optimization
opt_minvar_2 <- optimize.portfolio(R=R, portfolio=portf_minvar_2,
                                 optimize_method="ROI", trace=TRUE)
print(opt_minvar_2)
```
#now we do not go for short in any stock 

```{r}
bt_minvar_2 <- optimize.portfolio.rebalancing(R=R, portfolio=portf_minvar_2,
                                            optimize_method="ROI",
                                            rebalance_on="months",
                                            training_period=156)

bt_minvar_2

chart.Weights(bt_minvar_2)
returns_minvar <- Return.portfolio(R = R, weights = extractWeights(bt_minvar_2))
```

###third we use group constraint
```{r}
# Add group constraints to a new one in order to compare it and see differences
portf_minvar_3 <- portfolio.spec(assets=stockselection)
portf_minvar_3 <- add.constraint(portfolio=portf_minvar_3,
                               type="group",
                               groups=list(groupA=c(5,7,8,10),
                                           groupB=c(1,2,4),
                                           groupC=c(3,6,9)),
                               group_min=c(0.3, 0.2, 0),
                               group_max=c(0.8, 0.6, 0.5))
portf_minvar_3 <- add.objective(portfolio=portf_minvar_3, type="risk", name="var")
```

```{r}
#Optimization
# Run the optimization
opt_minvar_3 <- optimize.portfolio(R=R, portfolio=portf_minvar_3,
                                 optimize_method="ROI", trace=TRUE)
print(opt_minvar_3)
```

```{r}
bt_minvar_3 <- optimize.portfolio.rebalancing(R=R, portfolio=portf_minvar_3,
                                            optimize_method="ROI",
                                            rebalance_on="months",
                                            training_period=156)

bt_minvar_3

chart.Weights(bt_minvar_3)
returns_minvar <- Return.portfolio(R=R, weights=extractWeights(bt_minvar_3))
```

###now we put two constraints together

```{r}
portf_minvar_4 <- portfolio.spec(assets=stockselection)
portf_minvar_4 <- add.constraint(portfolio=portf_minvar_4, type="box",
                               min=0, max=1)
portf_minvar_4 <- add.objective(portfolio=portf_minvar_4, type="risk", name="var")
portf_minvar_4 <- add.constraint(portfolio=portf_minvar_4,
                               type="group",
                               groups=list(groupA=c(5,7,8,10),
                                           groupB=c(1,2,4),
                                           groupC=c(3,6,9)),
                               group_min=c(0.3, 0.2, 0),
                               group_max=c(0.8, 0.6, 0.5))
```

```{r}
#Optimization
# Run the optimization
opt_minvar_4 <- optimize.portfolio(R=R, portfolio=portf_minvar_4,
                                 optimize_method="ROI", trace=TRUE)
print(opt_minvar_4)
```

```{r}
bt_minvar_4 <- optimize.portfolio.rebalancing(R=R, portfolio=portf_minvar_4,
                                            optimize_method="ROI",
                                            rebalance_on="months",
                                            training_period=156)

bt_minvar_4

chart.Weights(bt_minvar_4)
returns_minvar <- Return.portfolio(R=R, weights=extractWeights(bt_minvar_4))
```

b) Maximum Quadratic Utility Portfolios

###first we used the full investment constraint
###second we combined it with the long-only constraint
```{r}
# Create initial portfolio object
init_portf <- portfolio.spec(assets=stockselection)
# Create full investment constraint
fi_constr <- weight_sum_constraint(type="full_investment")
# Create long only constraint
lo_constr <- box_constraint(type="long_only", assets=init_portf$assets)
# Combine the constraints in a list
qu_constr <- list(fi_constr, lo_constr)
# Create return objective
ret_obj <- return_objective(name="mean")
# Create variance objective specifying a risk_aversion parameter which controls
# how much the variance is penalized
var_obj <- portfolio_risk_objective(name="var", risk_aversion=4.00)
# Combine the objectives into a list
qu_obj <- list(ret_obj, var_obj)
```

```{r}
# Run the optimization
opt_qu <- optimize.portfolio(R=R, portfolio=init_portf,
                             constraints=qu_constr,
                             objectives=qu_obj,
                             optimize_method="ROI",
                             trace=TRUE)
opt_qu
```

```{r}
bt_qu <- optimize.portfolio.rebalancing(R=R, portfolio=init_portf,
                                        constraints=qu_constr,
                                        objectives=qu_obj,
                                        optimize_method="ROI",
                                        rebalance_on="months",
                                        training_period=156)
print(bt_qu)

chart.Weights(bt_qu)
returns_qu <- Return.portfolio(R = R, weights = extractWeights(bt_qu))
```

#there we cannot only use one constraint - that is why we only used them together

## Exercise 2: Estimating the CAPM

In this exercise we want to estimate the CAPM. Please read carefully through the two documents provided (right hand side: files). Then we start to collect the necessary data:
  
a) From Datastream get the last 10 years of data from the 100 stocks of the S&P100 using the list `LS&P100I` (S&P 100): total return index (RI) and market cap (MV)

```{r Getting the data from Thomson Reuter}
sp100 <- read_excel("sp100_monthly.xlsx",sheet = "Sheet1")
colnames(sp100)[1]  <- "date"
```



__It is false for both data.frames so therefore there are no NA's in our data.frames.__

b) Further import the Fama-French-Factors from Kenneth Frenchs homepage (monthly, e.g. using `FFdownload`). From both datasets we select data for the last (available) 60 months, calculate returns (simple percentage) for the US-Stocks and eliminate those stocks that have NAs for this period.

```{r Getting the Fama-French-Factors}
tempf <- tempfile(fileext = ".RData"); tempd <- tempdir(); temptxt <- tempfile(fileext = ".txt")
inputlist <- c("F-F_Research_Data_Factors")
# Now process only these files if they can be matched (download only)
FFdownload(exclude_daily=TRUE,tempdir=tempd,download=TRUE,download_only=FALSE,inputlist=inputlist)
tempf2 <- tempfile(fileext = ".RData"); tempd2 <- tempdir() 
FFdownload(output_file = tempf2,tempdir = tempd2,exclude_daily = TRUE, download = TRUE, download_only=FALSE, listsave=temptxt)
load(tempf2)

ff<-FFdownload$x_Developed_ex_US_3_Factors$monthly$Temp2
ff<-ff["2015/2020"]
sff<-timetk::tk_tbl(ff)
colnames(sff)[1]<-"date"
sff$RF <- sff$RF *100
sff
```

```{r Selecting data for the last 60 months so the last five years}
fil_sp100 <- dplyr::filter(sp100, date >= as.Date("2015-10-01"), date <= as.Date("2020-10-01"))
```

```{r Transforming the dates}
sp100_date <-as.yearmon(fil_sp100$date)
sp100 <- base::cbind(sp100_date, fil_sp100)
sp100$date <- NULL
colnames(sp100)[1] <- "date"
```

```{r Splitting the SP100 RI from the MV}
sp100_RI <- sp100 %>%
  dplyr:: select(grep("date", names(sp100)), grep("TOT RETURN IND", names(sp100)))
sp100_MV <- sp100 %>%
  dplyr:: select(grep("date", names(sp100)), grep("MARKET VALUE", names(sp100)))
```

```{r Checking if there is any NA in our dataset}
any(is.na(sp100_RI))
any(is.na(sp100_MV))
```
__Calculating the simple returns of the US-stocks__

```{r Returns in %}
calc <- function(x) diff(x)/x[-length(x)] * 100
op <- sp100_RI[,-1]

return <- data.matrix(op)
return <- apply(return, 2, calc)
any(is.na(return))
date <- dplyr::select(sp100, "date")
date = date[-1,]
date <- as.data.frame(date, col.names = date)
return <- cbind(date,return)
return <- return[-59,]
view(return)
```

```{r Shaping the Factors in order to get the RF}
sff = sff[-c(1,2,3,4,5,6,7,8,9,10),]
FFF <- dplyr::select(sff, c("date", "RF"))
view(FFF)
```

```{r Checking Na}
any(is.na(FFF))
any(is.na(return))
```


c) Now subtract the risk-free rate from all the stocks. Then estimate each stocks beta with the market: Regress all stock excess returns on the market excess return and save all betas (optimally use `mutate` and `map` in combination with `lm`). Estimate the mean-return for each stock and plot the return/beta-combinations. Create the security market line and include it in the plot! What do you find?

```{r Substracting the risk-free rate from all the stocks}
date <- return[,1]
return <- return [,-1]
ad_return <- return - FFF$RF
date <- as.data.frame(date, col.names = date)
return <- cbind(date,return)
return <- return[-59,]
ad_return <- cbind(date,ad_return)
ad_return <- return[-59,]
```

##ACHTUNG##
__Alles was jetzt kummt isch risky business bin ma ned sicher, ob des so passt__


__INFO__
https://rviews.rstudio.com/2018/02/08/capm-beta/
https://github.com/rstudio/cheatsheets/blob/master/purrr.pdf
Kann nur dia Website empfehle als alternativ LÃ¶sung, aber wegat am Market Input tÃ¤t i obacht gea, weil mit getSymbols gohts ned zumindest ned bei mir.

```{r Estimating beta with the market??????????????????????????}
#Create XTS
sff$RF <- sff$RF /100 # Als Market nehmen wir an das es uf die FF-Factors bezogen isch was also nur der Riskofreie Markt isch do mÃ¼sst ma uns no was ifalla lo im Sinne Returns from S&P500 (^GSPC) oder so nea.
mkt_xts <- tk_xts(data = sff, date_var = date)
port_rf_xts <- ad_return %>%
  tk_xts(date_var = date, silent = TRUE)

#Calculate Betas for each portfolio
betas_port <- lm(port_rf_xts ~ mkt_xts[, 1])
betas_port<- CAPM.beta(Ra = port_rf_xts, Rb = mkt_xts[, 1], Rf = 0)
```

```{r Return/Beta Combination}
#Estimate Mean Return
mean_portf_rf_xts <- lapply(port_rf_xts, FUN=mean)
mean_portf_rf_xts <- as.data.frame(mean_portf_rf_xts)

#Plot the return/beta-combinations
plot.default(x = betas_port, xlim=c(0, 2),
             y = mean_portf_rf_xts, ylim=c(0, 1),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations")
```
```{r Adding the SML}
mean_mkt <- lapply(mkt_xts[, 1], FUN=mean)
mean_mkt <- as.data.frame(mean_mkt)
y_mkt <- mean_mkt[1, 1]
plot.default(x = betas_port, xlim=c(0, 2),
             y = mean_portf_rf_xts, ylim=c(0, 1),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations",
             abline(0, y_mkt))

plot.default(x = betas_port, xlim=c(0, 2), 
             y = mean_portf_rf_xts, ylim=c(0, 10), #einziger Unterschied zum oberen Plot, wahrscheinlich andere Zoom_Settings.
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations",
             abline(0, y_mkt))
#summary
summary_CAPM_portf <- (table.CAPM(Ra = port_rf_xts, Rb = mkt_xts[, 1], Rf = 0)[1:9, ])
summary_CAPM_portf
```
The majority of the stocks have a smaller beta so they behave are more "risk averse" the Market has not so a big impact on the single stocks or at least the majority of it. There are a bunch of good performer, but the issue is it highly depends which "market" you chosse as a Security Market Line (SML).


__?NEXT STEPS?__
Im Bereich Files findasch dia Dokumente, aber wias usschaut mÃ¼sstan mir nomol uns Daten abazÃ¼ha 

d) In a next step (following both documents), we sort the stocks according to their beta and build ten value-weighted portfolios (with more or less the same number of stocks). Repeat a) for the ten portfolios. What do you observe?

e) In the third step you follow page 6-8 of the second document and estimate the second-pass regression with the market and then market & idiosyncratic risk. What do you observe? Present all your results in a similar fashion as in the document.


## Exercise 3: Calculating and checking the CAPM cont.

As we have seen: the CAPM for small portfolios does not work very well, and so we start using portfolios that get rid of the idiosyncratic risk!
Go to Kenneth French's Homepage  again and download the following datasets: "Portfolios Formed on Market Beta" (where we will use 10 monthly value weighted portfolios formed on beta) and "25 Portfolios Formed on Size and Market Beta" (same thing) as well as the market factor and rf (as before). Now we are going to check the CAPM like famous researchers have done it!
We can use returns as they are in the files (simple returns)!

a)	Subtract the risk-free rate from the first set of 10 portfolios (only sorted on beta) (Lo 10,., Hi 10) and estimate each stocks beta with the market. Estimate the mean-return for each stock and plot the return/beta-combinations. Create the security market line and include it in the plot! What do you find? (You can split the file in 2-3 different time blocks and see if something changes). * Now we are done with the first-pass regression.*
b)	In the second-pass regression we now regress the average stock returns on the betas estimated before. What do you find in the coefficients and does this contradict the CAPM? Try different time periods again and see what you find. (all of the interpretations are in BKM pp.416f). 
c)	Now do the extended second pass regression (regress on betas and residual-sds that you can extract from the regression) and see what you find for different periods. Interpret according to concept check 13.2. One of the (many) problems of the CAPM can be the correlation between residual variances and betas. Calculate and interpret.
d)	Try again with 25 portfolios sorted on size and beta. What do you find? Is that interesting? 

```{r}

#Download the Portfolios from Kenneth French's Homepage
portf_mkt_beta <- "https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/ftp/Portfolios_Formed_on_BETA_CSV.zip"
 portf_mkt_beta_csv <- "Portfolios_Formed_on_BETA.csv"
 temp <- tempfile()
download.file(portf_mkt_beta, temp, quiet = TRUE)
portf_mkt_beta <- read_csv(unz(temp, portf_mkt_beta_csv), skip = 15, quote = "\",") %>%
  dplyr::rename(date = "X1") %>%
  mutate_at(vars(-date), as.numeric) %>%
  mutate(date = rollback(ymd(parse_date_time(date, "%Y%m") + months(1))))%>%
  filter(date >= first('1964-01-01') & date <= '2018-12-31')

#Download the market factor and rf (Fama/French 3 Research Factors)
mkt_factors <- "https://mba.tuck.dartmouth.edu/pages/faculty/ken.french/ftp/F-F_Research_Data_Factors_CSV.zip"
 mkt_factors_csv <- "F-F_Research_Data_Factors.CSV"
 temp <- tempfile()
download.file(mkt_factors, temp, quiet = TRUE)
mkt_factors <- read_csv(unz(temp, mkt_factors_csv), skip = 3, quote = "\",") %>%
  dplyr::rename(date = X1) %>%
  mutate_at(vars(-date), as.numeric) %>%
  mutate(date = rollback(ymd(parse_date_time(date, "%Y%m") + months(1)))) %>%
  filter(date >= first('1964-01-01') & date <= '2018-12-31')

```

a)	Subtract the risk-free rate from the first set of 10 portfolios (only sorted on beta) (Lo 10,., Hi 10) and estimate each stocks beta with the market.

```{r}

#join data, substract Risk-Free-Rate
ten_portf <- portf_mkt_beta[1:660, -c(2:6)]
ten_portf_joined <- left_join(mkt_factors, ten_portf)
ten_portf_joined <- ten_portf_joined <- ten_portf_joined%>% dplyr::rename("Lo10" = "Lo 10") %>% dplyr::rename("Dec2" = "Dec 2") %>% dplyr::rename("Dec3" = "Dec 3") %>% dplyr::rename("Dec4" = "Dec 4") %>% dplyr::rename("Dec5" = "Dec 5") %>% dplyr::rename("Dec6" = "Dec 6") %>% dplyr::rename("Dec7" = "Dec 7") %>% dplyr::rename("Dec8" = "Dec 8") %>% dplyr::rename("Dec9" = "Dec 9") %>% dplyr::rename("Hi10" = "Hi 10")
ten_portf_rf <- mutate(ten_portf_joined, Lo10rf = Lo10 - RF, Dec2rf = Dec2 - RF, Dec3rf = Dec3 - RF, Dec4rf = Dec4 - RF, Dec5rf = Dec5 -RF, Dec6rf = Dec6 - RF, Dec7rf = Dec7 - RF, Dec8rf = Dec8 - RF, De9rf = Dec9 - RF, Hi10rf = Hi10 - RF)
ten_portf_rf <- ten_portf_rf[-2:-15]

#Create XTS
mkt_factors_xts <- tk_xts(data = mkt_factors, date_var = date)
ten_portf_rf_xts <- ten_portf_rf %>%
  tk_xts(date_var = date, silent = TRUE)

#Calculate Betas for each portfolio
betas_ten_portf_lm <- lm(ten_portf_rf_xts ~ mkt_factors_xts[, 1])
betas_ten_portf_lm
betas_ten_portf <- CAPM.beta(Ra = ten_portf_rf_xts, Rb = mkt_factors_xts[, 1], Rf = 0)
betas_ten_portf

```

Estimate the mean-return for each stock and plot the return/beta-combinations.

```{r}

#Estimate Mean Return
mean_ten_portf_rf_xts <- lapply(ten_portf_rf_xts, FUN=mean)
mean_ten_portf_rf_xts <- as.data.frame(mean_ten_portf_rf_xts)

#Plot the return/beta-combinations
plot.default(x = betas_ten_portf, xlim=c(0, 2),
             y = mean_ten_portf_rf_xts, ylim=c(0, 1),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations")

```

Create the security market line and include it in the plot! What do you find?

```{r}

mean_mkt <- lapply(mkt_factors_xts[, 1], FUN=mean)
mean_mkt <- as.data.frame(mean_mkt)
y_mkt <- mean_mkt[1, 1]
plot.default(x = betas_ten_portf, xlim=c(0, 2),
             y = mean_ten_portf_rf_xts, ylim=c(0, 1),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations",
             abline(0, y_mkt))

plot.default(x = betas_ten_portf, xlim=c(0, 2), 
             y = mean_ten_portf_rf_xts, ylim=c(0, 10), 
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations",
             abline(0, y_mkt))


#summary
summary_CAPM_ten_portf <- (table.CAPM(Ra = ten_portf_rf_xts, Rb = mkt_factors_xts[, 1], Rf = 0)[1:9, ])


```

(You can split the file in 2-3 different time blocks and see if something changes). * Now we are done with the first-pass regression.*


```{r}

#look for first 10 years
ten_portf_rf_10yrs_xts <- ten_portf_rf[1:120, ] %>%
  tk_xts(date_var = date, silent = TRUE)
betas_ten_portf_rf_10yrs <- CAPM.beta(Ra = ten_portf_rf_10yrs_xts, Rb = mkt_factors_xts[1:120, 1], Rf = 0)
mean_ten_portf_rf_10yrs_xts <- lapply(ten_portf_rf_10yrs_xts, FUN=mean)
mean_ten_portf_rf_10yrs_xts <- as.data.frame(mean_ten_portf_rf_10yrs_xts)
mean_mkt_10yrs <- lapply(mkt_factors_xts[1:120, 1], FUN=mean)
mean_mkt_10yrs <- as.data.frame(mean_mkt_10yrs)
y_mkt_10yrs <- mean_mkt_10yrs[1, 1]
plot.default(x = betas_ten_portf_rf_10yrs, xlim=c(0, 2),
             y = mean_ten_portf_rf_10yrs_xts, ylim=c(0, 1),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations 1964-1974",
             abline(0, y_mkt_10yrs))
summary_CAPM_ten_portf_10yrs <- (table.CAPM(Ra = ten_portf_rf_xts[1:120, ], Rb = mkt_factors_xts[1:120, 1], Rf = 0)[1:9, ])
summary_CAPM_ten_portf_10yrs

#look for 2000-2018
ten_portf_rf_2000_xts <- ten_portf_rf[433:660, ] %>%
  tk_xts(date_var = date, silent = TRUE)
betas_ten_portf_rf_2000 <- CAPM.beta(Ra = ten_portf_rf_2000_xts, Rb = mkt_factors_xts[433:660, 1], Rf = 0)
mean_ten_portf_rf_2000_xts <- lapply(ten_portf_rf_2000_xts, FUN=mean)
mean_ten_portf_rf_2000_xts <- as.data.frame(mean_ten_portf_rf_2000_xts)
mean_mkt_2000 <- lapply(mkt_factors_xts[433:660, 1], FUN=mean)
mean_mkt_2000 <- as.data.frame(mean_mkt_2000)
y_mkt_2000 <- mean_mkt_2000[1, 1]
plot.default(x = betas_ten_portf_rf_2000, xlim=c(0, 2),
             y = mean_ten_portf_rf_2000_xts, ylim=c(0, 1),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations 2000-2018",
             abline(0, y_mkt_2000))
summary_CAPM_ten_portf_2000 <- (table.CAPM(Ra = ten_portf_rf_xts[433:660, ], Rb = mkt_factors_xts[433:660, 1], Rf = 0)[1:9, ])
summary_CAPM_ten_portf_2000

plot.default(x = betas_ten_portf, xlim=c(0, 2),
             y = mean_ten_portf_rf_xts, ylim=c(0, 1),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations 1964-2018",
             abline(0, y_mkt))



```

b)	In the second-pass regression we now regress the average stock returns on the betas estimated before. What do you find in the coefficients and does this contradict the CAPM? Try different time periods again and see what you find. (all of the interpretations are in BKM pp.416f).

c)	Now do the extended second pass regression (regress on betas and residual-sds that you can extract from the regression) and see what you find for different periods. Interpret according to concept check 13.2. One of the (many) problems of the CAPM can be the correlation between residual variances and betas. Calculate and interpret.

```{r}

#Look at a) -> We now do it with the mean return of every portfolio combined... 

#1964-2018
com_mean_ten_portf_rf <- sum(mean_ten_portf_rf_xts)/10
mean_betas_ten_portf <- sum(betas_ten_portf)/10
plot.default(x = mean_betas_ten_portf, xlim=c(0, 2),
             y = com_mean_ten_portf_rf, ylim=c(0, 2),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations 10 Portfolios 1964-2018",
             abline(0, y_mkt))

#1964-1974
com_mean_ten_portf_rf_10yrs <- sum(mean_ten_portf_rf_10yrs_xts)/10
mean_betas_ten_portf_10yrs <- sum(betas_ten_portf_rf_10yrs)/10
plot.default(x = mean_betas_ten_portf_10yrs, xlim=c(0, 2),
             y = com_mean_ten_portf_rf_10yrs, ylim=c(0, 2),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations 10 Portfolios 1964-1974",
             abline(0, y_mkt_10yrs))

#2000-2018
com_mean_ten_portf_rf_2000 <- sum(mean_ten_portf_rf_2000_xts)/10
mean_betas_ten_portf_2000 <- sum(betas_ten_portf_rf_2000)/10
plot.default(x = mean_betas_ten_portf_2000, xlim=c(0, 2),
             y = com_mean_ten_portf_rf_2000, ylim=c(0, 2),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations 10 Portfolios 2000-2018",
             abline(0, y_mkt_2000))

#SML-Function
calc_residual <- function(x) {y <- y_mkt*x}
calc_residual_10yrs <- function(x) {y <- y_mkt_10yrs*x}
calc_residual_2000 <- function(x) {y <- y_mkt_2000*x}
residual_1964_2018 <- as.data.frame((com_mean_ten_portf_rf - calc_residual(mean_betas_ten_portf))^2)
residual_1964_1974 <- as.data.frame((com_mean_ten_portf_rf_10yrs - calc_residual_10yrs(mean_betas_ten_portf_10yrs))^2)
residual_2000_2018 <- as.data.frame((com_mean_ten_portf_rf_2000 - calc_residual_2000(mean_betas_ten_portf_2000))^2)
joined_residuals <- merge(residual_1964_2018[1, 1], residual_1964_1974[1, 1])
joined_residuals <- merge(joined_residuals, residual_2000_2018)
Residuals_different_timeperiods <- joined_residuals %>% 
  dplyr::rename("Residual 2000-2018" = "(com_mean_ten_portf_rf_2000 - calc_residual_2000(mean_betas_ten_portf_2000))^2") %>% dplyr::rename("Residual 1964-2008" = "x") %>% dplyr::rename("Residual 1964-1974" = "y")
Residuals_different_timeperiods


```


d)	Try again with 25 portfolios sorted on size and beta. What do you find? Is that interesting? 

```{r}

#join data, substract Risk-Free-Rate
twentyfive_portf <- portf_mkt_beta[1:660, -c(7:16)]
twentyfive_portf_joined <- left_join(mkt_factors, twentyfive_portf)
twentyfive_portf_joined <- twentyfive_portf_joined <- twentyfive_portf_joined%>%
  dplyr::rename("Lo20" = "Lo 20") %>%
  dplyr::rename("Qnt2" = "Qnt 2") %>%
  dplyr::rename("Qnt3" = "Qnt 3") %>%
  dplyr::rename("Qnt4" = "Qnt 4") %>%
  dplyr::rename("Hi20" = "Hi 20")
twentyfive_portf_rf <- mutate(twentyfive_portf_joined, Lo20rf = Lo20 - RF, Qnt2rf = Qnt2 - RF, Qnt3rf = Qnt3 - RF, Qnt4rf = Qnt4 - RF, Hi20rf = Hi20 - RF)
twentyfive_portf_rf <- twentyfive_portf_rf[-2:-10]

#Create XTS
twentyfive_portf_rf_xts <- twentyfive_portf_rf %>%
  tk_xts(date_var = date, silent = TRUE)

#Calculate Betas for each portfolio
betas_twentyfive_portf <- CAPM.beta(Ra = twentyfive_portf_rf_xts, Rb = mkt_factors_xts[, 1], Rf = 0)

#Estimate Mean Return
mean_twentyfive_portf_rf_xts <- lapply(twentyfive_portf_rf_xts, FUN=mean)
mean_twentyfive_portf_rf_xts <- as.data.frame(mean_twentyfive_portf_rf_xts)

#Plot the return/beta-combinations
plot.default(x = betas_twentyfive_portf, xlim=c(0, 2),
             y = mean_twentyfive_portf_rf_xts, ylim=c(0, 1),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations 25",
             abline(0, y_mkt))

#We now do it with the mean return of every portfolio combined...
com_mean_twentyfive_portf_rf <- sum(mean_twentyfive_portf_rf_xts)/5
# and the beta
mean_betas_twentyfive_portf <- sum(betas_twentyfive_portf)/5

plot.default(x = mean_betas_ten_portf, xlim=c(0, 2),
             y = com_mean_ten_portf_rf, ylim=c(0, 1),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations Portfolio Summary 25",
             abline(0, y_mkt))

plot.default(x = mean_betas_ten_portf, xlim=c(0, 2),
             y = com_mean_ten_portf_rf, ylim=c(0, 1),
             xlab = "Beta", ylab = "Mean Return",
             main = "Return/Beta-combinations Portfolio Summary 10",
             abline(0, y_mkt))
```
